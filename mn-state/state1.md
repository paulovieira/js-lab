Important concepts

Each view has an associanted "state", which is an instance of Mn.State. The Mn.State class is an extension of Mn.Object. It adds:
- a model: a dedicated model, which is where the the state is actually stored
- componentEvents: a hash of events that the state object will listen in the view (the view is the "state's component")
- utility methods like syncEntityEvents which are used to syncronize the state object with the state of external evented objects (other models, global app state, etc)

The essential idea is this: all changes to the DOM (controlled by the view) must happen as a consequence of a change in the view's state.

So if we use jquery to add a class or disable an element, that change happens because something else happened before (which was the said change in the state).

The change in the state can happen for several reasons. The most immediate one is when the user interacts with the view. Suppose the users clicks a button in the view. We could have an event handler listening to the click event and change the DOM directly in the handler. But this means we wouldn't have an easy way to get the current state (we would have to query the DOM for that). The objective is to keep the view's state in a separate object, out of the DOM. 

This way the state can be changed by different agents (a user interaction, a change in the url hash, a timeout, etc), and we know the view will always reflect the updated to the state.

So for the case when the user clicks the button the order of actions is the following:

 - user clicks the button
 - the view has a trigger for the click event, and triggers the corresponding (custom) event
 - the state associated to the view has a handler that is executed when that event is fired (see the "componentEvents" property)
 - the handler changes the state (that is, changes some attribute in the internal model that holds the state)
 - the view has an handler that is executed when there is a change in the state (see the "stateEvents" property)
 - the handler changes the DOM according the current state 

All this steps are necessary to make sure the DOM is changed only after the state changed. This way we are sure the DOM actually reflects the state.

The connection between the view and the state must be done in the following way:


In the view:

1) in the initialize method, we create an instance of the state and pass the "component" that is connected to the state (in this case is the view)

2) in the "triggers", we add a custom event that will be fired by the view to signal some user interaction that must change the state

3) we add a new "stateEvents" hash, relative to the events triggered by the state that the view will listen (usually these are "change" events; the view should do something to the DOM to reflect the change in the state)

4) finally, to  have the view listening the state events, we must call "Mn.State.syncEntityEvents" (usually in the "initialize" method)


In the state:

5) define the "defaultState", which is set at the beggining

6) define the "componentEvents" hash, relative to the events triggered by the view that the state will listen (these are the events generated by the view in consequence of some user interaction that should change the state)


This is like a domino falling. The chain of events is

a) user interaction happens (a click)
b) the view is listening for the click and triggers a custom event in consequence
c) the state is listening for the view's custom event and updates some state attribute in consequence
d) the view is listening for changes in the state's attribute, and updates the DOM in consequence

TODO: syncEntityEvents has a "render" param - why?

TODO: we might want to use the attributes of the state in the template. For instance, instead of adding/removing a class directly to a div, according to some change in the state, we re-render all the template. The logic for having the correct class would be in the template (assuming we use a powerful template engine, such as nunjucks). This however might not be a good idea if we lose the state of scroll, for instance, or the cursor of an inputf